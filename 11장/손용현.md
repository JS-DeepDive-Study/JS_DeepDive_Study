## **> 모던 자바스크립트 Deep Dive 제 11장 원시값과 객체의 비교 요약정리**<br/><br/>

### 원시타입과 객체타입의 차이점

- **원시 타입의 값, 즉 원시 값은 변경 불가능한 값**이다. 이에 비해 **객체(참조) 타입의 값, 즉 객체는 변강 가능한 값**이다.
- **원시값을 변수에 할당하면 변수(확보된 메모리 공간)에는 실제 값이 저장**된다. 이에 비해 **객체를 변수에 할당하면 변수(확보된 메모리 공간)에는 참조 값**이 저장된다.
- 값을 갖는 변수를 다른 변수에 할당하면 원본의 **원시 값이 복사되어 전달**된다. 이를 **값에 의한 전달**이라 한다. 이에 비해 객체를 가리키는 변수를 다른 변수에 할당하면 원본의 **참조 값이 복사되어 전달된다**. 이를 **참조에 의한 전달**이라 한다.

<br/>

### 11.1 원시 값

#### 11.1.1 변경 불가능한 값

> 원시값은 변경 불 가능한 값, 즉 읽기 전용 값이다.

원시 값을 할당한 변수에 새로운 원시 값을 재할당하면 메모리 공간에 저장되어 있는 **재할당 이전의 원시 값을 변경하는 것이 아니라** **새로운 메모리 공간**을 확보하고 재할당한 원시 값을 **저장**한 후, **변수는 새롭게 재할당한 원시 값을 가라킨다.** 이때 변수가 참조하던 **메모리 공간의 주소가 바뀐다.** 값의 이러한 특성을 **불변성**이라한다.

**불변성을 갖는 원시 값을 할당한 변수는 재할당 이외에 변수 값을 변경할 수 있는 방법이 없다.**

#### 11.1.2 문자열과 불변성

> ** 문자열**: 0개 이상의 문자로 이뤄진 집합을 말하며, **1개 문자는 2바이트 메모리 공간에 저장**되며, 유사 배열 객체이면서 이터러블이므로 배열과 유사하게 **각 문자에 접근**할 수 있다. 또한 **한번 생성된 문자열은 읽기 전용 값**으로서 **변경 불가능한 값**이다.

#### 11.1.3 값에 의한 전달

```
var score = 80;

// copy 변수에는 score 변수의 값 80이 복사되어 할당된다.
var copy = score;

console.log(score, copy); // 80 80
console.log(score === copy); //true

//score 변수와 copy 변수의 값은 다른 메모리 공간에 저장된 별개의 값이다.
// 따라서 score 변수의 값을 변경해도 copy 변수의 값에는 어떠한 영향도 주지 않는다.

score = 100;

console.log(score, copy) // 100 80
console.log(score4 === copy) // false
```

변수에 원시값을 갖는 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시 값이 복사되어 전달된다. 이를 **값에 의한 전달**이라 한다. 위 예제의 경우 (copy)변수에 원시 값을 갖는 score 변수를 할당하면 할당받는 변수(copy)에는 할당되는 변수(score)의 원시 값 80이 복사되어 전달된다.

따라서 변수(score)의 **값을 변경**해도 (copy)변수의 값에는 **어떠한 영향도 주지 않는다.**

변수와 같은 식별자는 값이 아니라 **메모리 주소**를 기억하고 있기에 변수에는 **메모리 값**이 전달된다.

- 새로운 80을 생성(복사)해서 메모리 주소를 전달하는 방식. 이 방식은 할당시점에 두 변수가 기억하는 메모리 주소가 다르다.
- score의 변수값 80의 메모리 주소를 그대로 전달하는 방식. 이 방식은 할당 시점에 두 변수가 기억하는 메모리 주소가 같다.

그래서 이 두가지 방법으로 **평가 방식이 가능**하다.

이처럼 값에 의한 전달도 **메모리 주소를 전달**하여 전달된 메모리 공간에 **접근**하여 **값을 참조**한다.

<br/>

### 11.2 객체

#### 11.2.1 변경 가능한 값

객체를 할당한 변수가 기억하는 메모리 주소를 통해 메모리 공간에 접근하면** 참조 값**에 접근할 수 있다. 참조 값은 생성된 객체가 저장된** 메모리 공간의 주소**, 그 자체다.

```
// 할당이 이뤄지는 시점에 객체 리터럴이 해석되고, 그 결과 객체가 생성된다.
var person = {
  name: 'Lee'
};

// person 변수에 저장되어 있는 참조 값으로 실제 객체에 접근한다.
console.log(person); // {name: "Lee"}
```

객체를 할당한 변수의 경우 "**변수는 객체를 참조하고 있다.**" 또는 "**변수는 객체를 가리키고 있다.**"라고 표현한다.

메모리를 효율적으로 사용하기 위해, 그리고 객체를 복사해 생성하는 비용을 절약하여 성능을 향상시키기 위해 객체는 **변경 가능한 값**으로 설계되어 있다.

객체는 이러한 구조적 잔점에 따른 부작용이 있다. 그것은 원시 값과는 다르게 **여래 개의 식별자가 하나의 객체를 공유할 수 있다는 것이다.**

#### - 얉은 복사와 깊은 복사 -

> **얉은 복사**: 한 단계까지만 복사하는 것을 뜻함
> **깊은 복사**: 객체에 중첩되어 있는 객체까지 모두 복사하는 것을 뜻함

얉은 복사와 깊은 복사로 생성된 객체는 **원본과 다른 개념**이다.

- **얇은 복사**는 객체에 중첩되어 있는 경우 참조 값을 복사한다.
- **깊은 복사**는 객체에 중첩되어 있는 객체까지 모두 복사해서 원시 값처럼 완전한 복사본을 만든다.

```
const o = {x : { y : 1 }};

//얕은 복사
const c1 = { ...o };
console.log(c1 === 0); //false;
console.log(c1.x === o.x) //true;

// lodash의 cloneDeep을 사용한 깊은 복사
// "npm install lodash"로 lodash를 설치한 후, Node.js 환경에서 실행
const _ = require('lodash')
// 깊은 복사
const c2 = _.cloneDeep(o);
console.log(c2 === o); // false;
console.log(c2.x === o.x); //false;
```

#### 11.2.2 참조에 의한 전달

> 객체를 가르키는 변수를 다른 변수에 할당하면 **원본의 참조 값이 복사되어 전달**된 것

![](https://velog.velcdn.com/images/joy10529/post/27d802b0-f943-4fb3-bb89-2e75ead13f74/image.png)

원본 person과 사본 copy는 저장된 메모리 주소는 다르지만 동일한 참조 값을 갖는다. 두 개의 식별자가 하나의 객체를 공유한다는 것을 의미한다. 따라서 원본 또는 사본 중 어느 한쪽에서 객체를 변경(변수에 새로운 객체를 재할당하는 것이 아니라 객체의 프로퍼티 값을 변경하거나 프로퍼티를 추가, 삭제)하면 서로 영향을 주고받는다.

```
var person = {
	name : 'Lee'
};

//참조 값을 복사(얕은 복사). copy와 person은 동일한 참조 값을 갖는다.
var copy = person;

//copy와 person은 동일한 객체를 참조한다.
console.log(copy === person); //true

// copy를 통해 객체를 변경한다.
copy.name = 'Kim';

//person을 통해 객체를 변경한다.
person.address = 'Seoul';

// copy와 person은 동일한 객체를 가리킨다.
// 따라서 어느 한쪽에서 객체를 변경하면 서로 영향을 주고 받는다.
console .log(person); // {name: "Kim" , address: "Seoul"}
console .log(copy); // {name: "Kim" , address: "Seoul"}
```

결국 **값에 의한 전달과 참조에 의한 전달은 식별자가 기억하는 메모리 공간에 저장되어 있는 값을 복사해서 전달한다는 면에서 동일하다.** 다만 식별자가 기억하는 메모리 공간, 즉 **변수에 저장되어 있는 값이 원시 값이냐 참조 값이냐의 차이만 있을 뿐이다.**

다만 **자바스크립트에는 "참조에 의한 전달"은 존재하지 않고 "값에 의한 전달"만이 존재한다고 말할 수 있다.**
그 이유는 자바스크립트에는 **포인터가 존재하지 않기 때문에** 포인터가 존재하는 다른 프로그래밍 언어의 참조에 의한 전달과 의미가 정확히 일치하지 않는다.
